//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma config(Hubs,  S1, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop)
//Add driving motors
#pragma DebuggerWindows("joystickGame")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

const int MOTOR_SCALAR = -128;
const int THRESHOLD = 10;



void initializeRobot()
{
	// Place code here to sinitialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	return;
}



task main()
{
	initializeRobot();

//	waitForStart();   // wait for start of tele-op phase

	while (true)
	{	

		if ((abs(joystick.joy1_x2) > THRESHOLD) || (abs(joystick.joy1_y2) > THRESHOLD))
		{
			motor[leftWheel] =  (((float)joystick.joy1_y2/MOTOR_SCALAR) - ((float)joystick.joy1_x2/MOTOR_SCALAR))*100;
			motor[rightWheel] = (((float)joystick.joy1_y2/MOTOR_SCALAR) + ((float)joystick.joy1_x2/MOTOR_SCALAR))*100;
		}
		else
		{
			motor[leftWheel] = 0;
			motor[rightWheel] = 0;
		}
	}	

}
